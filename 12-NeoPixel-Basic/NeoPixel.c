/*
 *   Basic OLED SSD1306 display driver
 */
#include "NeoPixel.h"
#include <string.h>
#include <stdlib.h>

uint8_t _x;                 // cursor column
uint32_t _bgColor = 0;       // background color
uint8_t buffer[3*N_LED + 3*NEO_EXT*8]; //    G, R, B,  buffer + extension char
uint8_t *_end = buffer + sizeof(buffer);

void NeoPixel_Send(uint8_t *p, uint8_t count) 
{   // sends count x RGB data packets (24-bit each)
    uint8_t bitCount, data;
    do {
        bitCount = 24;
        do {
            if ((bitCount & 7) == 0) {
                data = *p++ & POWER_LIMIT;    // optionally << to control brightness
            }
            SSP1BUF = ((data & 0x80)) ? 0xFE : 0xC0;  // WS2812B 900ns - 350ns           
            data <<= 1;
        } while (--bitCount);
        if (p >= _end) p = buffer;
    } while ( --count);
}

void NeoPixel_Show(void)
{
    NeoPixel_Send(buffer, N_LED);
}

void NeoPixel_SetColumn(uint8_t x)
{
    _x = x;
}

void NeoPixel_Clear(uint32_t color)
{
    uint8_t i,j, *bp = buffer;
    for(i=0; i<NEO_COLUMNS+NEO_EXT; i++)  // include the extension char
        for(j=0; j<NEO_ROWS; j++) {
            *bp++ = color >> 8;  // G
            *bp++ = color >> 16; // R
            *bp++ = color;       // B
        }
    _bgColor = color;
}

void NeoPixel_Gradient(uint32_t color, uint32_t grad)
{
    uint8_t i,j, *bp = buffer;
    uint8_t r, gr, g, gg, b, gb ;
    g = color >> 8;   r = color >> 16; b = color;
    gg = (grad >> 8);gr = grad >> 16; gb = grad;
    for(i=0; i<NEO_COLUMNS; i++) {
        for(j=0; j<NEO_ROWS; j++) {
            *bp++ = g;  // G
            *bp++ = r;  // R
            *bp++ = b;  // B
        }    
        g += gg; r += gr; b += gb;
    }
}

const uint8_t inv[8] = {15*3, 13*3, 11*3, 9*3, 7*3, 5*3, 3*3, 3};

void NeoPixel_ShiftLeft(void)
{
    uint8_t i, j, *bp = buffer;
    for(i=0; i<NEO_COLUMNS+NEO_EXT-1; i+=1) {
    // invert as you shift (zig zag pattern)
        for(j=0; j<8; j++) {
            memcpy(bp, &bp[inv[j]], 3);  // copy color information
            bp += 3;
        }
    }
}

const uint8_t font[] = { // 8 rows x 5 cols 
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x00,0x00,0x00,0x07,0x00,0x07,0x00, //	'sp,!,"
    0x14,0x7F,0x14,0x7F,0x14, // #
    0x24,0x2A,0x7F,0x2A,0x12,0x23,0x13,0x08,0x64,0x62,0x36,0x49,0x56,0x20,0x50, //	'$,%,&
    0x00,0x08,0x07,0x03,0x00,0x00,0x1C,0x22,0x41,0x00,0x00,0x41,0x22,0x1C,0x00, //	'',(,)
    0x2A,0x1C,0x7F,0x1C,0x2A,0x08,0x08,0x3E,0x08,0x08,0x00,0x00,0x70,0x30,0x00, //	'*,+,,
    0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x60,0x60,0x00,0x20,0x10,0x08,0x04,0x02, //	'-,.,/
    0x3E,0x51,0x49,0x45,0x3E,0x00,0x42,0x7F,0x40,0x00,0x72,0x49,0x49,0x49,0x46, //	'0,1,2
    0x21,0x41,0x49,0x4D,0x33,0x18,0x14,0x12,0x7F,0x10,0x27,0x45,0x45,0x45,0x39, //	'3,4,5
    0x3C,0x4A,0x49,0x49,0x31,0x41,0x21,0x11,0x09,0x07,0x36,0x49,0x49,0x49,0x36, //	'6,7,8
    0x46,0x49,0x49,0x29,0x1E,0x00,0x00,0x14,0x00,0x00,0x00,0x40,0x34,0x00,0x00, //	'9,:,;
    0x00,0x08,0x14,0x22,0x41,0x14,0x14,0x14,0x14,0x14,0x00,0x41,0x22,0x14,0x08, //	'<,=,>
    0x02,0x01,0x59,0x09,0x06,0x3E,0x41,0x5D,0x59,0x4E,                          //  '?,@
    0x7C,0x12,0x11,0x12,0x7C,                                                   //	'A
    0x7F,0x49,0x49,0x49,0x36,0x3E,0x41,0x41,0x41,0x22,0x7F,0x41,0x41,0x41,0x3E, //	'B,C,D
    0x7F,0x49,0x49,0x49,0x41,0x7F,0x09,0x09,0x09,0x01,0x3E,0x41,0x41,0x51,0x73, //	'E,F,G
    0x7F,0x08,0x08,0x08,0x7F,0x00,0x41,0x7F,0x41,0x00,0x20,0x40,0x41,0x3F,0x01, //	'H,I,J
    0x7F,0x08,0x14,0x22,0x41,0x7F,0x40,0x40,0x40,0x40,0x7F,0x02,0x1C,0x02,0x7F, //	'K,L,M
    0x7F,0x04,0x08,0x10,0x7F,0x3E,0x41,0x41,0x41,0x3E,0x7F,0x09,0x09,0x09,0x06, //	'N,O,P
    0x3E,0x41,0x51,0x21,0x5E,0x7F,0x09,0x19,0x29,0x46,0x26,0x49,0x49,0x49,0x32, //	'Q,R,S
    0x03,0x01,0x7F,0x01,0x03,0x3F,0x40,0x40,0x40,0x3F,0x1F,0x20,0x40,0x20,0x1F, //	'T,U,V
    0x3F,0x40,0x38,0x40,0x3F,0x63,0x14,0x08,0x14,0x63,0x03,0x04,0x78,0x04,0x03, //	'W,X,Y
    0x61,0x59,0x49,0x4D,0x43,                                                   //  'Z
    0x00,0x7F,0x41,0x41,0x41,0x02,0x04,0x08,0x10,0x20,                          //	'[,\ 
    0x00,0x41,0x41,0x41,0x7F,0x04,0x02,0x01,0x02,0x04,0x40,0x40,0x40,0x40,0x40, //	'],^,_
    0x00,0x03,0x07,0x08,0x00,0x20,0x54,0x54,0x38,0x40,0x7F,0x28,0x44,0x44,0x38, //	'`,a,b
    0x38,0x44,0x44,0x44,0x28,0x38,0x44,0x44,0x28,0x7F,0x38,0x54,0x54,0x54,0x18, //	'c,d,e
    0x00,0x08,0x7E,0x09,0x02,0x0C,0x52,0x52,0x4A,0x3C,0x7F,0x08,0x04,0x04,0x78, //	'f,g,h
    0x00,0x44,0x7D,0x40,0x00,0x20,0x40,0x40,0x3D,0x00,0x7F,0x10,0x28,0x44,0x00, //	'i,j,k
    0x00,0x41,0x7F,0x40,0x00,0x7C,0x04,0x78,0x04,0x78,0x7C,0x08,0x04,0x04,0x78, //	'l,m,n
    0x38,0x44,0x44,0x44,0x38,0x7C,0x18,0x24,0x24,0x18,0x18,0x24,0x24,0x18,0x7C, //	'o,p,q
    0x7C,0x08,0x04,0x04,0x08,0x48,0x54,0x54,0x54,0x24,0x04,0x04,0x3F,0x44,0x24, //	'r,s,t
    0x3C,0x40,0x40,0x20,0x7C,0x1C,0x20,0x40,0x20,0x1C,0x3C,0x40,0x30,0x40,0x3C, //	'u,v,w
    0x44,0x28,0x10,0x28,0x44,0x4C,0x50,0x50,0x50,0x3C,0x44,0x64,0x54,0x4C,0x44, //	'x,y,z
    0x00,0x08,0x36,0x41,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x41,0x36,0x08,0x00, //	'{,|,}
    0x02,0x01,0x02,0x04,0x02                                                    //  '~
    };

void NeoPixel_Putchar( char ch, uint32_t color)
{ // color is 0RGB
    uint8_t i, j, col;
    const uint8_t *f = &font[(ch-' ')*5];   // source pointer
    uint8_t *bp = &buffer[_x*24];           // dest pointer 
    uint8_t mask = 1;

    if (color == _bgColor) {    // if fore == back color -> randomize
        color = rand();
        color = ((color & 0xf800) << 8) + ((color & 0x7c0) << 2) + (color & 0x3f);
    }
    for( i=0; i<5; i++) {   // loop by columns        
        if (bp > _end) break;
        col = *f++;         // grab one column
        mask =  (_x & 1) ? 0x80 : 1;    // odd columns are MSB first
        for(j=0; j<8; j++) {     // loop by rows/pixels
            if (col & mask) {
                *bp++ = color >> 8;  // G
                *bp++ = color >> 16; // R
                *bp++ = color;       // B
            } else {
                *bp++ = _bgColor >> 8;  // G
                *bp++ = _bgColor >> 16; // R
                *bp++ = _bgColor;       // B
            }
            if (_x & 1) col <<= 1;  // odd lines shift left
            else col >>= 1;         // even lines shift right
        }        
        _x++;           // next column
    }
    _x++;
}

void NeoPixel_Puts( uint8_t x, char *s, uint32_t color)
{
    NeoPixel_SetColumn(x);    
    while( *s) {
        NeoPixel_Putchar( *s++, color);
    }
}

void NeoPixel_Scroll( char *s, uint32_t color, bool start)
{
    static uint8_t count=0, index=0;
    if (start) {
        NeoPixel_Clear( _bgColor);
        count = 0;
        index = 0;
        return;
    } 
    if (s[0] == 0) return;              // string empty
    if (s[count] == '\0') count=0;      // roll over
    if (index++ == 0) {
        NeoPixel_SetColumn(NEO_COLUMNS-1);    // point to the extension buffer
        NeoPixel_Putchar(s[count++], color);    
    }
    NeoPixel_ShiftLeft();
    NeoPixel_Show();
    index %= 6; 
}

